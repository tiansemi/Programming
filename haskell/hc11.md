# HC11 - Applications des classes de types et instances dérivées

Solutions pour HC11T1 → HC11T10. Chaque tâche inclut le code Haskell demandé et un `main` de test indépendant.

---

## HC11T1 : Instance `WeAccept` pour `Box`

```haskell
-- HC11T1

data Box a = Empty | Has a deriving (Show)

class WeAccept c where
    fancyFunction :: c -> String

-- On crée une instance WeAccept pour Box (si l'élément a est Show)
instance Show a => WeAccept (Box a) where
    fancyFunction Empty   = "Empty box - nothing to accept"
    fancyFunction (Has x) = "Accepted: " ++ show x

acceptedBoxes :: Show a => [Box a] -> [String]
acceptedBoxes = map fancyFunction

main :: IO ()
main = do
    let bs = [Has "Cardano", Empty, Has "Cash"]
    print (acceptedBoxes bs)
```

---

## HC11T2 : `fancyFunction` pour différents types

```haskell
-- HC11T2

data Box a = Empty | Has a deriving (Show)

class WeAccept c where
    fancyFunction :: c -> String

data PaymentMethod = Cardano | Cash | Country String deriving Show

instance WeAccept PaymentMethod where
    fancyFunction Cardano      = "We accept Cardano"
    fancyFunction Cash         = "We accept Cash"
    fancyFunction (Country c)  = "We accept payments from " ++ c

main :: IO ()
main = do
    putStrLn (fancyFunction Cardano)
    putStrLn (fancyFunction Cash)
    putStrLn (fancyFunction (Country "France"))
```

---

## HC11T3 : Classe `Container` pour `Box`

```haskell
-- HC11T3

data Box a = Empty | Has a deriving (Show)

class WeAccept c where
    fancyFunction :: c -> String
    
class Container c where
    isEmpty :: c a -> Bool
    contains :: Eq a => a -> c a -> Bool
    replace :: c a -> c a -> c a

instance Container Box where
    isEmpty Empty    = True
    isEmpty (Has _)  = False

    contains _ Empty = False
    contains y (Has x) = x == y

    replace _ new = new

main :: IO ()
main = do
    print (isEmpty (Empty :: Box Int))
    print (isEmpty (Has 5))
    print (contains 5 (Has 5))
    print (contains 3 (Has 5))
    print (replace (Has 1) (Has 2))
```

---

## HC11T4 : Instance `Container` pour `Present`

```haskell
-- HC11T4

class Container c where
    isEmpty :: c a -> Bool
    contains :: Eq a => a -> c a -> Bool
    replace :: c a -> c a -> c a
    
data Present a = NoPresent | Present a deriving (Show)

instance Container Present where
    isEmpty NoPresent    = True
    isEmpty (Present _)  = False

    contains _ NoPresent = False
    contains y (Present x) = x == y

    replace _ new = new

main :: IO ()
main = do
    print (isEmpty (NoPresent :: Present Int))
    print (isEmpty (Present 10))
    print (contains 10 (Present 10))
```

---

## HC11T5 : `guessWhat'sInside` pour `Container`

```haskell
-- HC11T5

guessWhat'sInside :: (Container c, Eq a) => a -> c a -> Bool
guessWhat'sInside = contains

main :: IO ()
main = do
    print (guessWhat'sInside 5 (Has 5))
    print (guessWhat'sInside 2 (Has 5))
```

---

## HC11T6 : `AdvancedEq` pour `Blockchain` (récursivité gérée)

```haskell
-- HC11T6

data Blockchain = BTC Int | ETH Int deriving Show

class AdvancedEq a where
    compareEquality :: a -> a -> Bool

instance AdvancedEq Blockchain where
    compareEquality (BTC n) (BTC m) = n == m
    compareEquality (ETH n) (ETH m) = n == m
    compareEquality _ _ = False

-- on définit Eq en s'appuyant sur compareEquality
instance Eq Blockchain where
    x == y = compareEquality x y
    x /= y = not (x == y)

main :: IO ()
main = do
    print (BTC 1 == BTC 1)
    print (BTC 1 == ETH 1)
```

---

## HC11T7 : Instance `Ord` pour `Box`

```haskell
-- HC11T7

instance (Ord a) => Ord (Box a) where
    compare Empty Empty = EQ
    compare Empty _     = LT
    compare _ Empty     = GT
    compare (Has x) (Has y) = compare x y

main :: IO ()
main = do
    print (Has 2 > Has 1)
    print (Empty < Has 0)
```

---

## HC11T8 : `deriving (Eq, Ord)` pour `PaymentMethod`

```haskell
-- HC11T8

data PaymentMethod2 = Cash2 | Card2 | Crypto2 deriving (Show, Eq, Ord)

main :: IO ()
main = do
    print (Cash2 == Card2)
    print (Crypto2 > Card2)
```

---

## HC11T9 : Type `Length` avec unités et comparaisons

```haskell
-- HC11T9

data Length = M Double | Km Double deriving Show

toMeters :: Length -> Double
toMeters (M x)  = x
toMeters (Km x) = x * 1000

instance Eq Length where
    l1 == l2 = toMeters l1 == toMeters l2

instance Ord Length where
    compare l1 l2 = compare (toMeters l1) (toMeters l2)

main :: IO ()
main = do
    print (M 1000 == Km 1)
    print (M 500 < Km 1)
```

---

## HC11T10 : Fonction `sortContainers`

```haskell
-- HC11T10

import Data.List (sort)

sortContainers :: (Ord (c a)) => [c a] -> [c a]
sortContainers = sort

main :: IO ()
main = do
    print (sortContainers [Has 3, Empty, Has 1])
```

---

Fin du document HC11. Si tu veux que je place tout cela dans un seul fichier `.hs` compilable (avec modules et imports organisés), je peux le faire.

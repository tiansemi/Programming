# Haskell Chapitre 9 – Solutions

## HC9T1 : Synonyme de type paramétrique

```haskell
type Entity a = (String, a)
```

## HC9T2 : Type de données paramétrique Box

```haskell
data Box a = Empty | Has a deriving Show
```

## HC9T3 : Fonction addN

```haskell
type Entity a = (String, a)

data Box a = Empty | Has a deriving Show

addN :: Num a => a -> Box a -> Box a
addN n Empty     = Empty
addN n (Has x)   = Has (n + x)

main :: IO ()
main = do
    let user :: Entity Int
        user = ("Alice", 42)
    print user

    let b1 :: Box Int
        b1 = Has 10
    print b1

    let b2 :: Box Int
        b2 = Empty
    print b2

    let b3 = addN 5 b1
    print b3

```

## HC9T4 : Fonction extract

```haskell
type Entity a = (String, a)

data Box a = Empty | Has a deriving Show

extract :: a -> Box a -> a
extract def Empty   = def
extract _   (Has x) = x

main :: IO ()
main = do
    -- Exemple d'Entity
    let user :: Entity Int
        user = ("Score", 15)
    print user

    -- Exemple de Box
    let b1 :: Box Int
        b1 = Has 42
    print b1

    let b2 :: Box Int
        b2 = Empty
    print b2

    -- Utilisation de extract
    let v1 = extract 0 b1   -- renvoie 42
    let v2 = extract 0 b2   -- renvoie 0 (valeur par défaut)
    
    putStrLn ("extract b1 = " ++ show v1)
    putStrLn ("extract b2 = " ++ show v2)

```

## HC9T5 : Type Shape paramétrique avec enregistrement

```haskell
type Entity a = (String, a)

data Box a = Empty | Has a deriving Show

data Shape a
    = Circle    { color :: a, radius :: Float }
    | Rectangle { color :: a, width :: Float, height :: Float }
    deriving Show

main :: IO ()
main = do
    -- Exemple d'Entity
    let user :: Entity Int
        user = ("Age", 21)
    print user

    -- Exemple de Box
    let b1 :: Box String
        b1 = Has "Hello"
    print b1

    let b2 :: Box Int
        b2 = Empty
    print b2

    -- Exemple de Shape
    let c1 :: Shape String
        c1 = Circle { color = "red", radius = 10.5 }
    print c1

    let r1 :: Shape String
        r1 = Rectangle { color = "blue", width = 4.0, height = 6.5 }
    print r1

    putStrLn "Programme terminé."

```

## HC9T6 : Type récursif Tweet

```haskell
type Entity a = (String, a)

data Box a = Empty | Has a deriving Show

data Tweet = Tweet
    { content  :: String
    , likes    :: Int
    , comments :: [Tweet]
    } deriving Show

main :: IO ()
main = do
    -- Exemple d'Entity
    let user :: Entity String
        user = ("username", "Satoshi")
    print user

    -- Exemple de Box
    let b1 :: Box Int
        b1 = Has 42
    print b1

    let b2 :: Box Tweet
        b2 = Empty
    print b2

    -- Exemple de Tweet simple
    let tweet1 = Tweet
            { content  = "Hello Haskell!"
            , likes    = 10
            , comments = []
            }
    print tweet1

    -- Exemple de Tweet avec commentaires (Tweet imbriqué)
    let reply1 = Tweet "Nice post!" 3 []
    let reply2 = Tweet "I agree!" 1 []
    let tweet2 = Tweet
            { content  = "Nested tweets are fun!"
            , likes    = 5
            , comments = [reply1, reply2]
            }
    print tweet2

    putStrLn "Programme terminé."

```

## HC9T7 : Fonction engagement

```haskell
type Entity a = (String, a)

data Box a = Empty | Has a deriving Show

data Tweet = Tweet
    { content  :: String
    , likes    :: Int
    , comments :: [Tweet]
    } deriving Show

-- Fonction d'engagement : likes + engagement de tous les commentaires
engagement :: Tweet -> Int
engagement (Tweet _ l cs) = l + sum (map engagement cs)

main :: IO ()
main = do
    -- Tweets de base
    let reply1 = Tweet "Nice post!" 3 []
    let reply2 = Tweet "I agree!" 1 []
    let reply3 = Tweet "Great explanation!" 7 []

    -- Tweet principal avec commentaires
    let mainTweet = Tweet
            { content = "Learning Haskell is fun!"
            , likes = 10
            , comments = [reply1, reply2, reply3]
            }

    -- Affichage du Tweet
    print mainTweet

    -- Affichage de l'engagement total
    putStrLn $ "Engagement total = " ++ show (engagement mainTweet)

```

## HC9T8 : Type récursif Sequence

```haskell
data Sequence a = End | Node a (Sequence a)
    deriving Show

-- Fonction utilitaire pour créer une Sequence à partir d'une liste
fromList :: [a] -> Sequence a
fromList []     = End
fromList (x:xs) = Node x (fromList xs)

-- Fonction pour afficher une Sequence (optionnel)
toList :: Sequence a -> [a]
toList End         = []
toList (Node x xs) = x : toList xs

main :: IO ()
main = do
    -- Création d'une séquence
    let seq1 = Node 1 (Node 2 (Node 3 End))
    print seq1

    -- Création depuis une liste
    let seq2 = fromList [10, 20, 30, 40]
    print seq2

    -- Conversion en liste normale
    putStrLn $ "Elements de seq2 : " ++ show (toList seq2)

```

## HC9T9 : Fonction elemSeq

```haskell
-- Définition de la séquence
data Sequence a = End | Node a (Sequence a) deriving Show

-- Fonction qui teste si un élément est présent
elemSeq :: Eq a => a -> Sequence a -> Bool
elemSeq _ End = False
elemSeq x (Node v rest) = x == v || elemSeq x rest

-- Exemple d'utilisation dans main
main :: IO ()
main = do
    let seq1 = Node 1 (Node 2 (Node 3 End))   -- Création d'une séquence d'exemple
    print $ elemSeq 2 seq1                     -- Devrait afficher True
    print $ elemSeq 5 seq1                     -- Devrait afficher False

```

## HC9T10 : Type BST (Binary Search Tree)

```haskell
-- Définition de l'arbre binaire de recherche
data BST a = EmptyBST
           | NodeBST a (BST a) (BST a)
           deriving Show

-- Fonction pour insérer un élément dans le BST
insertBST :: Ord a => a -> BST a -> BST a
insertBST x EmptyBST = NodeBST x EmptyBST EmptyBST
insertBST x (NodeBST v left right)
    | x < v     = NodeBST v (insertBST x left) right
    | x > v     = NodeBST v left (insertBST x right)
    | otherwise = NodeBST v left right  -- Ignorer si l'élément existe déjà

-- Fonction pour vérifier si un élément est dans le BST
elemBST :: Ord a => a -> BST a -> Bool
elemBST _ EmptyBST = False
elemBST x (NodeBST v left right)
    | x == v    = True
    | x < v     = elemBST x left
    | otherwise = elemBST x right

-- Exemple d'utilisation
main :: IO ()
main = do
    let tree = foldr insertBST EmptyBST [7, 3, 9, 1, 5]
    print tree
    print $ elemBST 5 tree   -- True
    print $ elemBST 8 tree   -- False

```

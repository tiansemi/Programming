# HC10 - Classes de types personnalisées et instances

Solutions pour HC10T1 → HC10T10. Chaque section inclut la définition demandée et un `main` de test.

---

## HC10T1 : Classe de type `ShowSimple`

```haskell
-- HC10T1

class ShowSimple a where
    showSimple :: a -> String

data PaymentMethod = Cash | Card | Cryptocurrency
    deriving (Show, Read)

instance ShowSimple PaymentMethod where
    showSimple Cash           = "Cash"
    showSimple Card           = "Card"
    showSimple Cryptocurrency = "Cryptocurrency"

main :: IO ()
main = do
    putStrLn (showSimple Cash)
    putStrLn (showSimple Card)
```

---

## HC10T2 : Classe de type `Summable`

```haskell
-- HC10T2

class Summable a where
    sumUp :: [a] -> a

instance Summable Int where
    sumUp = foldr (+) 0

main :: IO ()
main = do
    print (sumUp [1,2,3,4 :: Int]) -- 10
```

---

## HC10T3 : Classe de type `Comparable` pour `Blockchain`

```haskell
-- HC10T3

class Comparable a where
    compareWith :: a -> a -> Ordering

data Blockchain = BTC Int | ETH Int
    deriving (Show)

instance Comparable Blockchain where
    -- on compare selon la "valeur" numérique attachée
    compareWith (BTC n) (BTC m) = compare n m
    compareWith (ETH n) (ETH m) = compare n m
    -- choix arbitraire pour comparer différentes chaînes
    compareWith (BTC _) (ETH _) = LT
    compareWith (ETH _) (BTC _) = GT

main :: IO ()
main = do
    print (compareWith (BTC 10) (BTC 20)) -- LT
    print (compareWith (ETH 5) (BTC 1))  -- GT
```

---

## HC10T4 : `Eq` pour `Box a`

```haskell
-- HC10T4

data Box a = Empty | Has a deriving (Show)

instance (Eq a) => Eq (Box a) where
    Empty    == Empty    = True
    (Has x)  == (Has y)  = x == y
    _        == _        = False

main :: IO ()
main = do
    print (Has 3 == Has 3)
    print (Has 3 == Empty)
```

---

## HC10T5 : Classe `ShowDetailed` pour `User`

```haskell
-- HC10T5

class ShowDetailed a where
    showDetailed :: a -> String

data User = User { uname :: String, uage :: Int }

instance ShowDetailed User where
    showDetailed (User n a) = "User: " ++ n ++ ", age: " ++ show a

main :: IO ()
main = do
    putStrLn (showDetailed (User "Alice" 30))
```

---

## HC10T6 : `Eq` pour `Blockchain` (remarque sur la récursivité mutuelle)

```haskell
-- HC10T6

-- On réutilise le type Blockchain défini plus haut.
-- En pratique, l'instance Eq définit (==) et on peut définir (/=) via not (==).
-- C'est la façon sûre et standard :

instance Eq Blockchain where
    (BTC n) == (BTC m) = n == m
    (ETH n) == (ETH m) = n == m
    _       == _       = False
    x /= y = not (x == y)

main :: IO ()
main = do
    print (BTC 1 == BTC 1)
    print (BTC 1 /= ETH 1)
```

> **Note** : la "récursivité mutuelle" stricte entre `==` et `/=` (où chacun appelle l'autre sans cas de base) mène à une boucle infinie. La pratique correcte est de définir `==` (ou `/=`) et d'implémenter l'autre en utilisant `not` pour éviter de boucler.

---

## HC10T7 : Classe `Convertible` et implémentation PaymentMethod -> String

```haskell
-- HC10T7

class Convertible a b where
    convert :: a -> b

instance Convertible PaymentMethod String where
    convert Cash           = "cash"
    convert Card           = "card"
    convert Cryptocurrency = "crypto"

main :: IO ()
main = do
    putStrLn (convert Card)
```

---

## HC10T8 : Sous-classe `AdvancedEq` de `Eq`

```haskell
-- HC10T8

class Eq a => AdvancedEq a where
    compareEquality :: a -> a -> Bool

instance AdvancedEq Int where
    compareEquality x y = x == y

main :: IO ()
main = do
    print (compareEquality (5 :: Int) 5)
    print (compareEquality (3 :: Int) 4)
```

---

## HC10T9 : Classe `MinMax` avec instance pour Int

```haskell
-- HC10T9

class MinMax a where
    minValue :: a
    maxValue :: a

instance MinMax Int where
    minValue = minBound
    maxValue = maxBound

main :: IO ()
main = do
    print (minValue :: Int)
    print (maxValue :: Int)
```

---

## HC10T10 : Classe `Concatenatable` pour `String`

```haskell
-- HC10T10

class Concatenatable a where
    concatWith :: a -> a -> a

instance Concatenatable String where
    concatWith = (++)

main :: IO ()
main = do
    putStrLn (concatWith "Hello, " "world!")
```

---

Fin du document HC10. Si tu veux, je peux :

* fournir un fichier `HC10.hs` compilable qui regroupe tous les tests dans un menu interactif ;
* expliquer une tâche en détail ;
* modifier les instances pour utiliser des contraintes additionnelles (Ord, Bounded, ...).
